// Todo: different type of error messages will be investigated and added to the API.
// This helps/guides clients to create the correct request.
//
// in answer: never removes domains.
// what additional errors you would like to have
// todo: look into general API errors.

// todo: special fields in de email test. -> bijvoorbeeld -> dmarc reject + spf-all -> parked domain.
// zie spreadsheet van mail.

// all names have underscores instead of hyphens, so it can be accessed in javascript with much more ease.
// design decision: all test metadata and results are in a list. This is due to the better orderability.
// Direct access can easily be created by looping over the list once. The "test" field is always unique.
// and can be used to directly access the information like this:
// scan.domains["nu.nl"].results.web_ipv_ns_address.icon
{
  "scan": "f284049256dd4ca793edbcd4ae41759a",
  "metadata": {
    "tracking_information": "My web test",
    // web, mail and any other scan on a single endpoint.
    "scan_type": "web/mail",
    "api_version": "2",
    "submission_date": "2017-10-05T10:16:19.316626+00:00",
    "finished_date": "2017-10-05T10:26:19.316626+00:00"
  },

  // Todo: make this a separate request, as that cleans up a little.
  // this is stuff that stays the same per test. This should not be repeated to reduce data.
  // Should this be defined elsewhere, things won't really change here. It CAN however influence the display in
  // clients.

  "result_metadata": {
      // Todo: will not be duplicated as key and value.
      // Perhaps i have to specify the keynames for the test.
      // Todo: document how the keys are constructed: web/mail - category - subtest -
      // Todo: also document that they stay the same, so you cannot depend on this hierarcy.
      // Goal: see where the test should be.
      // Todo: use keys instad of a list of things.
      "web_ipv6_ns_address":  {
        // fields like title, subtitle, explanation, etc are implicit. They are available for all calculated
        // results and results in the translations.
        "translation": {
          // Where to find the correct translation of this result.
          "key": "web-mail_ipv6_ns-AAAA"

          // removed: this is obvious from the translation files.
          // these are the fields that are available to explain a test.
          // "fields": ["title", "explanation"]
        },



        // displayed on internet.nl, some special fields are not shown on internet.nl but are returned
        // are they still needed, will they be released in the future?
        // should we add a field "when" a field has been added? At what API version.
        // and we should also note that since when it is displayed. So we can specify fields without
        // releasing them? At least the API should reflect the documentation / design and should NOT be different.

        // the tradeoff: should it be documented in the API or should fields be documented in the documentation?


      // The hierarchy represents a way how internet.nl renders the test in a specific order.
      // There are two hierarchies, one with
      // The goal is to extract the hierarchy from the data, so the data can be parsed simply.
      // Perhaps the hierarchy needs to be completely separated in a separate structure (just in documentation)
      // The hieriarchy over different test is the same every time. This means it should not be added here.
      // A hierarchy is always stored separate from the test result. Hierarchies are hard to code and an easy
      // scope creep.
      "hierarchy": {
        "human": "/web/ipv6/nameserver/address",
        // create a report in the same order as on internet.nl
        "system": [1,1,1,1]
      }
    },
    "web_ipv6_ns_reach": {
      "translation_key": "web-mail_ipv6_ns-reach",
      "hierarchy": {
        // The human hierarchy is an english directory structure that somewhat helps to place this item
        // This is purely documentation to help document the system hierarchy.
        // This hierarchy is seperate from the test key names.
        "human": "/web/ipv6/nameserver/reachability",
        // a system can simply order the items based on string comparison. this allows UI to be built correctly
        // with new test in the right place (if desired by somebody that implements the API).
        // you can just do a a>b to order the fields. And then you want to have easy access to the name.
        // so to have no list of this makes it hard to sort things...
        // documents to prevent "where should something be"
        "system": [1,1,1,2]
      }
    },
    "ipv6": {
      "translation": {
        "key": "web_cat_ipv6"
      },
      "hierarchy": {
        "human": "/web/ipv6/",
        "system": [1,1]
      }
    },
    "web": {
      "translation": {
        "key": "web"
      },
      "hierarchy": {
        "human": "/web/",
        "system": [1]
      }
    }
  },
  "domains": [
    // Any printable character can be a key. this works.
    // Should the order be relevant? If not, this approach makes parsing / retrieving a specific value as simple
    // as:  Which prevents iterating through the array.
    // names are unique anyway, so they can be the key. A domain is never scanned twice.
    {
      // We keep the domain field here, so it's easy to do object.keys, and not work with the key but treat it
      // as a list (which is randomly ordered then...)
      // todo: also by key
      "domain": "nu.nl",

      // todo: add documentation
      "status": ["failed, success"],

      // Isn't this just a derived result, but with different data? At least now it's extendable with
      // differen options to wqualifiers. Also supports deprecation and such.
      "score": {
        "percentage": 80,
        // not be used, but example that it can be extenable: "icon": ""
      },
      "report": {
        "id": 814640,
        // Easier to directly access
        "address": "https://..."
      },
      // categories are now derived results. These can be derived from the result set and are added to
      // make it easier to represent certain overall categories or difficult to calculate values.
      "derived_results": [
        {
          "test": "ipv6",
          "verdict": "passed",
          "icon": "category_passed",
          // should we translations between verdict and translations?
          "translation": {
            "verdict": "not_signed"
          }
        }
      ],
      "results": [
        // resulting this as a list by default makes it easier to determine that all the items in the list
        // have the same format. The results can be ordered for example by the above hierarcy.

        // todo: perhaps i have to specify all keys you'll get back. Which is more explicit.
        // todo: define all, and put a documentaiton link to all of these values in the results.
        // Could i link to the verdicts? Or should i look to the example results page.
        // George will set up a documentation page.
        {
          "test": "web_ipv6_ns_address",
          // are verdict and icon always the same? George will check.
          "verdict": "passed",
          "icon": "passed",
          // Can't have a generic table for the translation. This is different per test and can be
          // very specific, while the test is warning.
          "translation": {
            "verdict": "good"
          },
          "technical_details": {}
        },
        {
          "test": "web_ipv6_ns_reach",
          "verdict": "passed",
          "icon": "passed",
          "translation": {
            "verdict": "good"
          },
          // This is to illustrate a complex technical data section can be added, while we're not doing this now.
          "technical_details": {
            // result metadata + get headers. Hedaer is a string in translation file with pipes for each header.
            // To get the translation, use the result metadata translation key, and then concatenate that with
            // "tech table".
            // a list of lists with undefined length. We should also document the headers and such.
            "data_matrix": [
              // todo: ... How to translate these fields then? secuire, insecrue, pahse, out, insufficient, etc
            ]
          }
        }
      ]
    }
  ]
}